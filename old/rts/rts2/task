 Приобрести практические навыки работы с механизмами синхронизации и взаимодействия
 потоков в многопотоковой системе.

 Познакомиться с функционалом стандарта POSIX, посвященного
 синхронизации потоков:  заголовочные файлы pthread.h, sched.h, semaphore.h.

 Решить одну из классических задач синхронизации в информатике: с классическим
 или модифицированным условием. Для решения задачи необходимо использовать определенный
 механизм синхронизации, предоставляемой QNX: мьютексы, семафоры, спинлоки, блокировки
 чтения-записи, условные переменные,  барьеры, или любой (любые) на собственное усмотрение,
 если в задании не указан конкретный механизм для решения. В данном случае для решения
 запрещается использовать способы, которые указаны в других вариантах с данной задачей.

 -------------------------------------------------------------------------------------
    Вариант: Проблема обедающих философов. Решение на основе монитора. 10 философов.
 -------------------------------------------------------------------------------------

  ---------- Проблема обедающих философов: Постановка задачи ----------
  Пять безмолвных философов сидят вокруг круглого стола, перед
  каждым философом стоит тарелка спагетти. Вилки лежат на столе
  между каждой парой ближайших философов.

  Каждый философ может либо есть, либо размышлять. Приём пищи не
  ограничен количеством оставшихся спагетти — подразумевается
  бесконечный запас. Тем не менее, философ может есть только тогда,
  когда держит две вилки — взятую справа и слева.

  Каждый философ может взять ближайшую вилку (если она доступна),
  или положить — если он уже держит её. Взятие каждой вилки и
  возвращение её на стол являются раздельными действиями, которые
  должны выполняться одно за другим.

  Суть проблемы заключается в том, чтобы разработать модель поведения
  (параллельный алгоритм), при котором ни один из философов не будет
  голодать, то есть будет вечно чередовать приём пищи и размышления.
  ---------------------------------------------------------------------

  ---------- Проблема обедающих философов: Проблемы ----------
  Задача сформулирована таким образом, чтобы иллюстрировать
  проблему избежания взаимной блокировки — состояния системы,
  при котором прогресс невозможен.

  Проблема ресурсного голодания может возникать независимо от
  взаимной блокировки, если один из философов не может
  завладеть левой и правой вилкой из-за проблем синхронизации.

  Системы, которые должны иметь дело с большим количеством
  параллельных процессов, используют тысячи блокировок и
  точек синхронизации. Это требует строгого соблюдения методик
  и протоколов, если необходимо избегать взаимных блокировок,
  голодания и повреждения данных.
  ------------------------------------------------------------

  ---------- Проблема обедающих философов: Решение на основе монитора ----------
  В отсутствие блокировок, связанных с вилками, философы должны обеспечивать то,
  что начало принятия пищи не основывается на старой информации о состоянии
  соседей. Например: Если философ B видит, что A не ест в данный момент времени,
  а потом поворачивается и смотрит на C, A мог начать есть, пока философ B
  смотрит на C. Используя одну взаимоисключающую блокировку (Мьютекс), можно
  избежать этой проблемы. Эта блокировка не связана с вилками, но она связана с
  решением процедур, которые могут изменить состояние философов. Это
  обеспечивается монитором.

  Алгоритм монитора реализует схему «проверить, взять и положить» и совместно
  использует взаимоисключающую блокировку. Заметьте, что философы, желающие есть,
  не будут иметь вилок.

  Если монитор разрешает философу, желающему есть, действовать, то философ снова
  завладевает первой вилкой, прежде чем взять уже свободную вторую.

  По окончании текущего приёма пищи философ оповещает монитора о том, что обе
  вилки свободны.

  Стоит заметить, что этот алгоритм монитора не решает проблемы голодания.
  Например, философ B может бесконечно ждать своей очереди, если у философов A и
  C периоды приёма пищи всё время пересекаются. Чтобы гарантировать также, что
  ни один философ не будет голодать, можно отслеживать, сколько раз голодный
  философ не ел, когда его соседи положили вилки на стол. Если количество раз
  превысит некий предел, такой философ перейдёт в состояние Голодания и алгоритм
  монитора форсирует процедуру завладения вилками, выполняя условие недопущения
  голодания ни одного из соседей.

  Философ, не имеющий возможности взять вилки из-за того, что его сосед
  голодает, находится в режиме полезного ожидания окончания приёма пищи соседом
  его соседа. Эта дополнительная зависимость снижает параллелизм. Увеличение
  значения порога перехода в состояние Голодание уменьшает этот эффект.